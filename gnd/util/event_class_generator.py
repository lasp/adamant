# This function is a class constructor (via closure). It creates an event class
# that is specific to a given component's event. The class is parameterized
# by the component's name, the event's name, and the parameter class, which
# is usually an autocoded python class inheriting from PackedTypeBase.
def create_event_cls(component_instance_name, event_name, param_type_cls):
    from event import Event

    class SpecificEvent(Event):
        # Override the __init__ function so that we can accept the
        # actual parameter of type param_type_cls:
        def __init__(self, Header=None, Param=None):
            # Store the event name:
            self.component_instance_name = component_instance_name
            self.event_name = event_name
            self.has_param = False

            # Make sure param is of the appropriate class:
            param_buffer = None
            if Param is not None:
                self.has_param = True
                assert isinstance(Param, param_type_cls), (
                    "Expected type for field 'param' to be '"
                    + str(param_type_cls)
                    + "' and instead found '"
                    + str(type(Param))
                )
                param_buffer = list(Param.to_byte_array())
            self.Param = Param

            # Call the base class initializer:
            super(SpecificEvent, self).__init__(
                Header=Header, Param_Buffer=param_buffer
            )

        # Override the _from_byte_array method so that we can also
        # decode the argument:
        def _from_byte_array(self, stream):
            # First call the base class decoder:
            super(SpecificEvent, self)._from_byte_array(stream)

            # Now use the param_buffer to decode into our specific parameter type:
            if self.Param_Buffer:
                self.Param = param_type_cls.create_from_byte_array(
                    bytes(self.Param_Buffer)
                )

        def pretty_print_string(self):
            seconds = 0
            subseconds = 0
            id = 0
            param = ""
            if self.Header:
                if self.Header.Time:
                    if self.Header.Time.Seconds:
                        seconds = self.Header.Time.Seconds
                    if self.Header.Time.Subseconds:
                        subseconds = self.Header.Time.Subseconds
                    if self.Header.Id:
                        id = self.Header.Id
            if self.Param:
                param = ": " + self.Param.to_tuple_string()

            return "%010d.%09d - %s.%s (0x%04X) %s" % (
                seconds,
                int((subseconds / (2**32)) * 1000000000),
                self.component_instance_name,
                self.event_name,
                id,
                param,
            )

    return SpecificEvent


# Testing code:
if __name__ == "__main__":
    # Build our dependencies using the build system.
    # This is necessary because some of the depdencies we
    # have are autogenerated.
    from util import pydep

    pydep.build_py_deps()

    # Imports:
    import sys
    from tick import Tick
    from sys_time import Sys_Time
    from event_header import Event_Header

    # Create an event class with a tick as an argument parameter:
    tick_event_cls = create_event_cls("My_Component", "The_Event", Tick)

    # Instantiate two objects of this event type, one filled in, and one not:
    empty_event = tick_event_cls()
    sys.stderr.write(empty_event.pretty_print_string() + "\n")
    filled_event = tick_event_cls(
        header=Event_Header(
            time=Sys_Time(15, 70000), id=10, param_buffer_length=Tick().size_in_bytes
        ),
        param=Tick(time=Sys_Time(15, 70000), count=15),
    )
    sys.stderr.write(filled_event.pretty_print_string() + "\n")

    # Fill the empty event and print it again:
    empty_event.from_byte_array(filled_event.to_byte_array())
    sys.stderr.write(empty_event.pretty_print_string() + "\n")
    assert empty_event == filled_event
