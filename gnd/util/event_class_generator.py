def create_event_cls(component_instance_name, event_name, param_type_cls):
    """
    This function is a class constructor (via closure). It creates an event class
    that is specific to a given component's event. The class is parameterized
    by the component's name, the event's name, and the parameter class, which
    is usually an autocoded python class inheriting from PackedTypeBase.
    """
    from event import Event

    class SpecificEvent(Event):
        def __init__(self, Header=None, Param=None):
            """
            Override the __init__ function so that we can accept the
            actual parameter of type param_type_cls:
            """
            # Store the event name:
            self.component_instance_name = component_instance_name
            self.event_name = event_name
            self.has_param = False

            # Make sure param is of the appropriate class:
            param_buffer = None
            if Param is not None:
                self.has_param = True
                assert isinstance(Param, param_type_cls), (
                    "Expected type for field 'param' to be '"
                    + str(param_type_cls)
                    + "' and instead found '"
                    + str(type(Param))
                )
                param_buffer = list(Param.to_byte_array())
            self.Param = Param

            # Call the base class initializer:
            super(SpecificEvent, self).__init__(
                Header=Header, Param_Buffer=param_buffer
            )

        def _from_byte_array(self, stream):
            """
            Override the _from_byte_array method so that we can also
            decode the argument:
            """
            # First call the base class decoder:
            super(SpecificEvent, self)._from_byte_array(stream)

            # Now use the param_buffer to decode into our specific parameter type:
            if self.Param_Buffer:
                self.Param = param_type_cls.create_from_byte_array(
                    bytes(self.Param_Buffer)
                )

        def pretty_print_string(self):
            seconds = 0
            subseconds = 0
            id = 0
            param = ""
            if self.Header:
                if self.Header.Time:
                    if self.Header.Time.Seconds:
                        seconds = self.Header.Time.Seconds
                    if self.Header.Time.Subseconds:
                        subseconds = self.Header.Time.Subseconds
                    if self.Header.Id:
                        id = self.Header.Id
            if self.Param:
                param = ": " + self.Param.to_tuple_string()

            return "%010d.%09d - %s.%s (0x%04X) %s" % (
                seconds,
                int((subseconds / (2**32)) * 1000000000),
                self.component_instance_name,
                self.event_name,
                id,
                param,
            )

    return SpecificEvent


# Testing code:
if __name__ == "__main__":
    # Build our dependencies using the build system.
    # This is necessary because some of the dependencies we
    # have are autogenerated.
    from util import pydep

    pydep.build_py_deps()

    # Imports:
    import sys
    from tick import Tick
    from sys_time import Sys_Time
    from event_header import Event_Header

    # Create an event class with a tick as an argument parameter:
    tick_event_cls = create_event_cls("My_Component", "The_Event", Tick)

    # Instantiate two objects of this event type, one filled in, and one not:
    empty_event = tick_event_cls()
    sys.stderr.write(empty_event.pretty_print_string() + "\n")
    filled_event = tick_event_cls(
        header=Event_Header(
            time=Sys_Time(15, 70000), id=10, param_buffer_length=Tick().size_in_bytes
        ),
        param=Tick(time=Sys_Time(15, 70000), count=15),
    )
    sys.stderr.write(filled_event.pretty_print_string() + "\n")

    # Fill the empty event and print it again:
    empty_event.from_byte_array(filled_event.to_byte_array())
    sys.stderr.write(empty_event.pretty_print_string() + "\n")
    assert empty_event == filled_event
