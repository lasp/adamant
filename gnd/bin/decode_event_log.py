#!/usr/bin/env python3
import argparse
from util import meta
from util import pydep
from util import redo
from util import crc_16

# We have a few autocoded dependencies we need to import. So do that:
pydep.build_py_deps()
from ccsds_space_packet import Ccsds_Space_Packet
from event import Event
from circular_buffer_meta import Circular_Buffer_Meta
from sys_time import Sys_Time
from memory_region import Memory_Region
from bitstring import ReadError

# This python utility is meant to be run from the command
# line. When run it decodes events from a post mortem log
# dump and prints its output to the commandline:
if __name__ == "__main__":
    # Parse the commandline arguments:
    parser = argparse.ArgumentParser(
        description="Decode a post mortem event log dump file."
    )
    parser.add_argument(
        "assembly_events_file",
        metavar="assembly_events.py",
        type=str,
        help="The autogenerated assembly events python file.",
    )
    parser.add_argument(
        "pm_file",
        metavar="post_mortem_dump.bin",
        type=str,
        help="The post mortem event log dump file.",
    )
    args = parser.parse_args()

    # Build the assembly events file if it is not constructed yet:
    redo.redo_ifchange(args.assembly_events_file)

    # Build the dependencies of the events file:
    pydep.build_py_deps(source_file=args.assembly_events_file)

    # Import the events file so we can use it:
    assembly_events = meta.import_module_from_filename(args.assembly_events_file)

    # Read the post mortem file:
    with open(args.pm_file, mode="rb") as f:
        content = f.read()

    content_len = len(content)
    print(
        "Opening "
        + str(args.pm_file)
        + " which contains "
        + str(content_len)
        + " bytes."
    )

    # The binary data should be a set of CCSDS packets, so extract those:
    packets = []
    data = []
    idx = 0
    while idx < len(content):
        try:
            packet = Ccsds_Space_Packet.create_from_byte_array(content[idx:])
            packet_bytes = packet.to_byte_array()
            idx += len(packet_bytes)
            packets.append(packet)
        except ReadError:
            print("Encountered read error at byte: " + str(idx))
            break
        # Validate checksum of packet
        if list(packet_bytes[-2:]) == crc_16.crc_16(packet_bytes[0:-2]):
            # Extract time:
            time = Sys_Time.create_from_byte_array(bytes(packet.Data))
            # Extract memory region:
            region = Memory_Region.create_from_byte_array(
                bytes(packet.Data[time.serialized_length():])
            )
            # Extract data:
            data.extend(
                packet.Data[time.serialized_length() + region.serialized_length():-2]
            )
            print(
                "Parsed valid CCSDS packet with time: "
                + time.to_tuple_string()
                + " id: "
                + str(packet.Header.Apid)
                + " sequence count: "
                + str(packet.Header.Sequence_Count)
                + " length: "
                + str(packet.Header.Packet_Length)
                + " and memory region: "
                + region.to_tuple_string()
            )
        else:
            print(
                "Could not parse INVALID CCSDS packet with id: "
                + str(packet.Header.Apid)
                + " sequence count: "
                + str(packet.Header.Sequence_Count)
                + " and length: "
                + str(packet.Header.Packet_Length)
                + " and expected CRC: "
                + str(crc_16.crc_16(packet_bytes[0:-2]))
                + " actual CRC: "
                + str(list(packet_bytes[-2:]))
            )
            print(str(packet))

    # The first portion of the data should be the circular buffer meta data. Print that out:
    first_data_index = 0
    if data:
        meta = Circular_Buffer_Meta.create_from_byte_array(bytes(data))
        first_log_index = meta.serialized_length()
        print("")
        print("Event log meta data:")
        print(str(meta.to_tuple_string()))
        print("")

    # Print out the events in the rest of the packets. Loop through all data
    # starting at the meta data head, and ending at the meta data count. Wrap
    # around to the beginning if needed.
    print("Event log:")
    idx = first_log_index + meta.Head
    count = 0
    while count < meta.Count:
        # Decode event:
        event = Event.create_from_byte_array(bytes(data[idx:]))

        # Find specific event class using id:
        specific_event_cls = assembly_events.event_id_cls_dict[event.Header.Id]
        specific_event = specific_event_cls.create_from_byte_array(bytes(data[idx:]))
        print(specific_event.pretty_print_string())

        # Increment the index by the length of the event:
        count += event.serialized_length()
        idx += event.serialized_length()
        if idx >= meta.Size:
            idx = first_log_index
