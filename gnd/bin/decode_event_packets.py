#!/usr/bin/env python3
import argparse
from util import meta
from util import pydep
from util import redo
from util import crc_16

# We have a few autocoded depdendencies we need to import. So do that:
pydep.build_py_deps()
from ccsds_space_packet import Ccsds_Space_Packet
from event import Event
from sys_time import Sys_Time
from bitstring import ReadError

# This python utility is meant to be run from the command
# line. When run it decodes events from a post mortem log
# dump and prints its output to the commandline:
if __name__ == "__main__":
    # Parse the commandline arguments:
    parser = argparse.ArgumentParser(
        description="Decode a log dump of FSS event packets."
    )
    parser.add_argument(
        "assembly_events_file",
        metavar="assembly_events.py",
        type=str,
        help="The autogenerated assembly events python file.",
    )
    parser.add_argument(
        "pm_file",
        metavar="post_mortem_dump.bin",
        type=str,
        help="The post mortem event log dump file.",
    )
    args = parser.parse_args()

    # Build the assembly events file if it is not constructed yet:
    redo.redo_ifchange(args.assembly_events_file)

    # Build the dependencies of the events file:
    pydep.build_py_deps(source_file=args.assembly_events_file)

    # Import the events file so we can use it:
    assembly_events = meta.import_module_from_filename(args.assembly_events_file)

    # Read the post mortem file:
    with open(args.pm_file, mode="rb") as f:
        content = f.read()

    content_len = len(content)
    print(
        "Opening "
        + str(args.pm_file)
        + " which contains "
        + str(content_len)
        + " bytes."
    )

    # The binary data should be a set of CCSDS packets, so extract those:
    packets = []
    data = []
    idx = 0
    while idx < len(content):
        try:
            packet = Ccsds_Space_Packet.create_from_byte_array(content[idx:])
            packet_bytes = packet.to_byte_array()
            idx += len(packet_bytes)
            packets.append(packet)
        except ReadError:
            print("Encountered read error at byte: " + str(idx))
            break
        # Validate checksum of packet
        if list(packet_bytes[-2:]) == crc_16.crc_16(packet_bytes[0:-2]):
            # Extract time:
            time = Sys_Time.create_from_byte_array(bytes(packet.Data))
            print(
                "Parsed valid CCSDS packet with time: "
                + time.to_tuple_string()
                + " id: "
                + str(packet.Header.Apid)
                + " sequence count: "
                + str(packet.Header.Sequence_Count)
                + " length: "
                + str(packet.Header.Packet_Length)
            )
            # Extract data:
            data.extend(packet.Data[time.serialized_length():-2])
        else:
            print(
                "Could not parse INVALID CCSDS packet with id: "
                + str(packet.Header.Apid)
                + " sequence count: "
                + str(packet.Header.Sequence_Count)
                + " and length: "
                + str(packet.Header.Packet_Length)
                + " and expected CRC: "
                + str(crc_16.crc_16(packet_bytes[0:-2]))
                + " actual CRC: "
                + str(list(packet_bytes[-2:]))
            )
            print(
                str(
                    crc_16.crc_16(packet_bytes[0:7 + packet.Header.Packet_Length - 2])
                )
            )
            # Extract time:
            time = Sys_Time.create_from_byte_array(bytes(packet.Data))
            # Extract data:
            data.extend(packet.Data[time.serialized_length():-2])

    # Print out the events in the rest of the packets:
    print("Event log:")
    idx = 0
    while idx < len(data):
        # Decode event:
        event = Event.create_from_byte_array(bytes(data[idx:]))

        # Find specific event class using id:
        specific_event_cls = assembly_events.event_id_cls_dict[event.Header.Id]
        try:
            specific_event = specific_event_cls.create_from_byte_array(
                bytes(data[idx:])
            )
            print(specific_event.pretty_print_string())
        except BaseException as e:
            print("Problem parsing event id: " + str(event.Header.Id) + "\n" + str(e))

        # Increment the index by the length of the event:
        idx += event.serialized_length()
