#!/usr/bin/env python3
import sys
import argparse
import socket
import logging
from util import meta
from util import crc_16
from datetime import datetime

# This python utility is meant to be run from the command
# line. When run it decodes events from a UDP socket
# and prints its output to the commandline and to a file:
if __name__ == "__main__":
    # Parse the commandline arguments:
    parser = argparse.ArgumentParser(description="Decode a event log dump.")
    parser.add_argument(
        "ip", metavar="IP", type=str, help="IP of socket you want to connect to"
    )
    parser.add_argument(
        "port", metavar="Port", type=int, help="Port of socket you want to connect to"
    )
    parser.add_argument(
        "app_id",
        metavar="App_ID",
        type=int,
        help="App ID of the commands you want to decode",
    )
    parser.add_argument(
        "assembly_events_file",
        metavar="assembly_events.py",
        type=str,
        help="The autogenerated assembly events python file.",
    )
    parser.add_argument(
        "log_file",
        metavar="decoder.log",
        type=str,
        help="The name of the file you want to log to.",
    )
    parser.add_argument(
        "-P",
        action="store_true",
        help=("Run in production mode. Program does not try to import or build autocoded dependencies. "
              "It expects a file called assembly_events.py to exist in the same directory as the "
              "executable that contains the assembly events file."),
    )
    parser.add_argument(
        "--udp",
        action="store_true",
        help="Run using UDP instead of the default, TCP (the ip address argument still needed, but is ignored).",
    )
    parser.add_argument(
        "--module-dependencies",
        action="store_true",
        help="Print python module dependencies to aid pyinstaller.",
    )
    parser.add_argument(
        "--python-path",
        action="store_true",
        help="Print python path dependencies to aid pyinstaller.",
    )
    args = parser.parse_args()

    # We have a few autocoded depdendencies we need to import. So do that:
    if not args.P:
        from util import pydep

        pydep.build_py_deps()

    # Import the autocoded packages now that they are built.
    from ccsds_space_packet import Ccsds_Space_Packet
    from event import Event
    from sys_time import Sys_Time

    if not args.P:
        # Build the assembly events file if it is not constructed yet:
        from util import redo

        redo.redo_ifchange(args.assembly_events_file)
        # Build the dependencies of the events file:
        pydep.build_py_deps(source_file=args.assembly_events_file)

    # Import the events file so we can use it:
    assembly_events = meta.import_module_from_filename(args.assembly_events_file)

    # If the python path flag was set, then print the python path and exit.
    if args.python_path:
        for path in sys.path:
            print(path)
        sys.exit(0)

    # If the module dependencies flag was set, then print the modules and exit.
    if args.module_dependencies:
        for name, module in sys.modules.items():
            if hasattr(module, "__file__"):
                print(name)
        sys.exit(0)

    # start logger
    logging.basicConfig(
        filename=args.log_file, filemode="a", format="%(message)s", level=logging.INFO
    )

    # Define a useful print log function:
    def print_log(strn):
        print(strn)
        logging.info(strn)

    def timestamp_str():
        return str(datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

    # Set up socket:
    message = b"test"
    addr = (args.ip, args.port)
    if args.udp:
        addr = ("", args.port)
        client_socket = socket.socket(
            socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP
        )
        client_socket.bind(addr)
        print_log("Connected to UDP at:" + str(addr))
    else:
        addr = (args.ip, args.port)
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # try to connect to socket
        try:
            client_socket.connect(addr)
        except socket.error:
            print_log("Connection refused | Exiting")
            client_socket.close()
            sys.exit(1)
        print_log("Connected to TCP at:" + str(addr))

    # Grab max packet length from a Ccsds_Space_Packet
    temp_pack = Ccsds_Space_Packet()
    packet_len = temp_pack._max_serialized_length
    min_packet_len = temp_pack._min_serialized_length

    # Decode incomoing packets:
    print_log("Starting event logging at " + timestamp_str() + ":")
    while True:
        try:
            event_data, server = client_socket.recvfrom(packet_len)
            # print_log("got data: " + str(len(event_data)))
            # If data is large enough to be a valid packet, the try to pase it.
            if event_data and len(event_data) >= min_packet_len:
                # The binary data should be a set of CCSDS packets, so extract those:
                packet = Ccsds_Space_Packet.create_from_byte_array(event_data)
                if packet.Header.Apid == args.app_id:
                    # Validate checksum of packet
                    if packet.Data[-2:] == crc_16.crc_16(packet.to_byte_array()[0:-2]):
                        # Extract time:
                        time = Sys_Time.create_from_byte_array(bytes(packet.Data))
                        # Extract data:
                        data = packet.Data[time.serialized_length():-2]
                        # logging.info("Parsed valid CCSDS packet with time:%s id:%s sequence count:%s and length:%s", \
                        # time.to_tuple_string(), str(packet.Header.Apid), str(packet.Header.Sequence_Count), \
                        # str(packet.Header.Packet_Length))
                        # Decode the events in the rest of the packet:
                        idx = 0
                        while idx < len(data):
                            event = Event.create_from_byte_array(bytes(data[idx:]))
                            # Find specific event class using id:
                            try:
                                specific_event_cls = assembly_events.event_id_cls_dict[
                                    event.Header.Id
                                ]
                                specific_event = (
                                    specific_event_cls.create_from_byte_array(
                                        bytes(data[idx:])
                                    )
                                )
                                # log event
                                print_log(specific_event.pretty_print_string())
                            except KeyError:
                                print_log(
                                    "Received unrecognized event with id: "
                                    + str(event.Header.Id)
                                )
                            except BaseException as e:
                                print_log(
                                    "Error encountered while parsing event with id: "
                                    + str(event.Header.Id)
                                    + "\n"
                                    + str(e)
                                )

                            # Increment the index by the length of the event:
                            idx += event.serialized_length()
                    else:
                        print_log(
                            "Could not parse INVALID CCSDS packet with id:%s sequence count:%s and length:%s"
                            % (
                                str(packet.Header.Apid),
                                str(packet.Header.Sequence_Count),
                                str(packet.Header.Packet_Length),
                            )
                        )

        except socket.error:
            client_socket.close()
            print_log(
                "Socket error occured: {} | Exiting".format(socket.error)
                + " at "
                + timestamp_str()
            )
            sys.exit(0)
        except KeyboardInterrupt:
            client_socket.close()
            print_log("Socket Closed | Exiting at " + timestamp_str())
            sys.exit(0)
        except BaseException as e:
            print_log("Unexpected error occured:\n" + str(e))
