from models.packets import packets, packet
from models.exceptions import ModelException
from util import model_loader
from util import redo


class command_sequencer_packets(packets):
    """
    This model is a specialized packet suite for the command sequencer packets. This
    class inherits from the normal packets model but adds some extra functionality
    needed to the sequence packet. In particular, the sequence packet's
    type is derived from its initialization parameters
    """
    def submodel_name(self):
        """This is just a "decorated" packet object, so make sure everyone treats it like that."""
        return "packets"

    def set_assembly(self, assembly):
        # Set assembly:
        self.assembly = assembly

        # The command sequencer packet contents are autogenerated based on the number
        # of engines and stacks in each engine. This number is provided at initialization in the assembly
        # model. The FSW does not need this type to correctly populate the packet, but ground
        # tools and assembly documentation do. So, we dynamically assign a type to this packet
        # at assembly runtime.
        for key, pkt in self.entities.items():
            # Find the packet we need to fill the type in for.
            if (
                pkt.suite.component.name == "Command_Sequencer"
                and pkt.name == "Summary_Packet"
            ):
                model_name = (
                    self.assembly.name + "_command_sequencer_summary_packet_type"
                )
                model_path = model_loader.get_model_file_path(
                    model_name, model_types=["record"]
                )
                if not model_path:
                    raise ModelException(
                        "Could not find Command Sequencer packet type model file: '"
                        + model_name
                        + "'."
                    )

                # Make sure the model file has been autogenerated. Note that this causes a circular
                # dependency loop if shallow_load is not set to True in the generator
                # for the packet type.
                redo.redo_ifchange(model_path)

                # Now replace the packet by a new packet with the autogenerated type.
                self.entities[key] = packet(
                    name=pkt.name,
                    type=model_name + ".T",
                    description=pkt.description,
                    id=pkt.id,
                    suite=pkt.suite,
                )

                # Let's also add the type to our suite and component's complex types:
                self.type_models.append(self.entities[key].type_model)
                self.component.complex_types[
                    self.entities[key].type_model.name
                ] = self.entities[key].type_model

            # Find second packet:
            if (
                pkt.suite.component.name == "Command_Sequencer"
                and pkt.name == "Details_Packet"
            ):
                model_name = (
                    self.assembly.name + "_command_sequencer_details_packet_type"
                )
                model_path = model_loader.get_model_file_path(
                    model_name, model_types=["record"]
                )
                if not model_path:
                    raise ModelException(
                        "Could not find Command Sequencer packet type model file: '"
                        + model_name
                        + "'."
                    )

                # Make sure the model file has been autogenerated. Note that this causes a circular
                # dependency loop if shallow_load is not set to True in the generator
                # for the packet type.
                redo.redo_ifchange(model_path)

                # Now replace the packet by a new packet with the autogenerated type.
                self.entities[key] = packet(
                    name=pkt.name,
                    type=model_name + ".T",
                    description=pkt.description,
                    id=pkt.id,
                    suite=pkt.suite,
                )

                # Let's also add the type to our suite and component's complex types:
                self.type_models.append(self.entities[key].type_model)
                self.component.complex_types[
                    self.entities[key].type_model.name
                ] = self.entities[key].type_model

        # Call the base class version:
        super(command_sequencer_packets, self).set_assembly(assembly)
