from models.packets import packets, packet
from models.exceptions import ModelException
from util import model_loader
from util import redo


class sequence_store_packets(packets):
    """
    This model is a specialized packet suite for the sequence store packet. This
    class inherits from the normal packets model but adds some extra functionality
    needed to the sequence packet. In particular, the sequence packet's
    type is derived from its initialization parameters, ie. it produces a summary for
    each slot passed to the component at init.
    """
    def submodel_name(self):
        """This is just a "decorated" packet object, so make sure everyone treats it like that."""
        return "packets"

    def set_assembly(self, assembly):
        # Set assembly:
        self.assembly = assembly

        # The sequence store slot summaries packet type is autogenerated based on the number
        # of slots that it manages. This number is provided at initialization in the assembly
        # model. The FSW does not need this type to correctly populate the packet, but ground
        # tools and assembly documentation do. So, we dynamically assign a type to this packet
        # at assembly runtime.
        for key, pkt in self.entities.items():
            # Find the packet we need to fill the type in for.
            if (
                pkt.suite.component.name == "Sequence_Store"
                and pkt.name == "Slot_Summaries"
            ):
                # First, lets get the path to the model file that will be the type for this packet:
                sequence_slots = self.component.init.get_parameter_value(
                    "Sequence_Slots"
                )
                if "." in sequence_slots:
                    sequence_slots_package = sequence_slots.split(".")[0]
                    model_name = sequence_slots_package + "_record"
                    model_path = model_loader.get_model_file_path(
                        model_name, model_types=["record"]
                    )
                    if not model_path:
                        raise ModelException(
                            "Could not find Slot_Summaries packet type model file: '"
                            + model_name
                            + "'."
                        )

                    # Make sure the model file has been autogenerated. Note that this causes a circular
                    # dependency loop if shallow_load is not set to False in the generator
                    # for the packet type.
                    redo.redo_ifchange(model_path)

                    # Now replace the packet by a new packet with the autogenerated type.
                    self.entities[key] = packet(
                        name=pkt.name,
                        type=model_name + ".T",
                        description=pkt.description,
                        id=pkt.id,
                        suite=self,
                    )

                    # Let's also add the type to our suite and component's complex types:
                    self.type_models.append(self.entities[key].type_model)
                    self.component.complex_types[
                        self.entities[key].type_model.name
                    ] = self.entities[key].type_model
                else:
                    raise ModelException(
                        "Sequence_Slots param: '" + sequence_slots + "' not parsable."
                    )

        # Call the base class version:
        super(sequence_store_packets, self).set_assembly(assembly)
