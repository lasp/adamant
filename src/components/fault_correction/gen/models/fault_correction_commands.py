from models.commands import commands, command
from models.exceptions import ModelException
from util import model_loader
from util import redo


# This model is a specialized data product suite for the fault correction component.
# This class inherits from the normal data product model but adds some extra functionality
# needed for the fault correction component. In particular, one of the data products for
# the fault correction component derives its type from its autocoded input parameters.
# The code below stuffs this derived type into the correct data product at assembly
# load time.
class fault_correction_commands(commands):
    # This is just a "decorated" data product object, so make sure everyone treats it like that.
    def submodel_name(self):
        return "commands"

    def set_assembly(self, assembly):
        # Make sure an assembly is set by the base class implementation.
        super(fault_correction_commands, self).set_assembly(assembly)

        # Get the model for the fault responses so that we can create the status record.
        configs = self.component.init.get_parameter_value(
            "Fault_Response_Configurations"
        )
        fault_responses_package = configs.split(".")[0]
        # fault_responses_model = model_loader.try_load_model_by_name(
        #     fault_responses_package, model_types="fault_responses"
        # )

        # Build the enum for the type.
        model_name = fault_responses_package + "_Enums"
        model_path = model_loader.get_model_file_path(model_name, model_types=["enums"])
        if not model_path:
            raise ModelException(
                "Could not find fault response type model file: '" + model_name + "'."
            )

        # Make sure the model file has been autogenerated. Note that this causes a circular
        # dependency loop if set_submodels_and_components is not set to False in the generator
        # for the packet type.
        redo.redo_ifchange(model_path)

        # Build the type for the command.
        model_name = fault_responses_package + "_Packed_Id_Type"
        model_path = model_loader.get_model_file_path(
            model_name, model_types=["record"]
        )
        if not model_path:
            raise ModelException(
                "Could not find fault response type model file: '" + model_name + "'."
            )

        # Make sure the model file has been autogenerated. Note that this causes a circular
        # dependency loop if set_submodels_and_components is not set to False in the generator
        # for the packet type.
        redo.redo_ifchange(model_path)

        # OK, now stuff this new type into the command for our component.
        cmd = self.get_with_name("Enable_Fault_Response")
        self.entities["Enable_Fault_Response"] = command(
            name=cmd.name,
            type=model_name + ".T",
            description=cmd.description,
            id=cmd.id,
            suite=self,
        )
        cmd = self.get_with_name("Disable_Fault_Response")
        self.entities["Disable_Fault_Response"] = command(
            name=cmd.name,
            type=model_name + ".T",
            description=cmd.description,
            id=cmd.id,
            suite=self,
        )
        cmd = self.get_with_name("Clear_Fault_Response")
        self.entities["Clear_Fault_Response"] = command(
            name=cmd.name,
            type=model_name + ".T",
            description=cmd.description,
            id=cmd.id,
            suite=self,
        )

        # Let's also add the type to our suite and component's complex types:
        self.type_models.append(self.entities["Enable_Fault_Response"].type_model)
        self.component.complex_types[
            self.entities["Enable_Fault_Response"].type_model.name
        ] = self.entities["Enable_Fault_Response"].type_model
