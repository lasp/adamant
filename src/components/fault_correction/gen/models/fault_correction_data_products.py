from models.data_products import data_products, data_product
from models.exceptions import ModelException
from util import model_loader
from util import redo


class fault_correction_data_products(data_products):
    """
    This model is a specialized data product suite for the fault correction component.
    This class inherits from the normal data product model but adds some extra functionality
    needed for the fault correction component. In particular, one of the data products for
    the fault correction component derives its type from its autocoded input parameters.
    The code below stuffs this derived type into the correct data product at assembly
    load time.
    """
    def submodel_name(self):
        """This is just a "decorated" data product object, so make sure everyone treats it like that."""
        return "data_products"

    def set_assembly(self, assembly):
        # Make sure an assembly is set by the base class implementation.
        super(fault_correction_data_products, self).set_assembly(assembly)

        # Get the model for the fault responses so that we can create the status record.
        configs = self.component.init.get_parameter_value(
            "Fault_Response_Configurations"
        )
        fault_responses_package = configs.split(".")[0]
        # fault_responses_model = model_loader.try_load_model_by_name(
        #     fault_responses_package, model_types="fault_responses"
        # )

        # Build the type for the data product.
        model_name = fault_responses_package + "_Status_Record"
        model_path = model_loader.get_model_file_path(
            model_name, model_types=["record"]
        )
        if not model_path:
            raise ModelException(
                "Could not find fault response type model file: '" + model_name + "'."
            )

        # Make sure the model file has been autogenerated. Note that this causes a circular
        # dependency loop if set_submodels_and_components is not set to False in the generator
        # for the packet type.
        redo.redo_ifchange(model_path)

        # OK, now stuff this new type into the data product for our component.
        fault_response_statuses_dp = self.get_with_name("Fault_Response_Statuses")
        self.entities["Fault_Response_Statuses"] = data_product(
            fault_response_statuses_dp.name,
            model_name + ".T",
            description=fault_response_statuses_dp.description,
            id=fault_response_statuses_dp.id,
            suite=self,
        )

        # Let's also add the type to our suite and component's complex types:
        self.type_models.append(self.entities["Fault_Response_Statuses"].type_model)
        self.component.complex_types[
            self.entities["Fault_Response_Statuses"].type_model.name
        ] = self.entities["Fault_Response_Statuses"].type_model

        # Build the enum for the type.
        model_name = fault_responses_package + "_Enums"
        model_path = model_loader.get_model_file_path(model_name, model_types=["enums"])
        if not model_path:
            raise ModelException(
                "Could not find fault response type model file: '" + model_name + "'."
            )

        # Make sure the model file has been autogenerated. Note that this causes a circular
        # dependency loop if set_submodels_and_components is not set to False in the generator
        # for the packet type.
        redo.redo_ifchange(model_path)

        # Build the type for the data product.
        model_name = fault_responses_package + "_Packed_Id_Type"
        model_path = model_loader.get_model_file_path(
            model_name, model_types=["record"]
        )
        if not model_path:
            raise ModelException(
                "Could not find fault response type model file: '" + model_name + "'."
            )

        # Make sure the model file has been autogenerated. Note that this causes a circular
        # dependency loop if set_submodels_and_components is not set to False in the generator
        # for the packet type.
        redo.redo_ifchange(model_path)

        # OK, now stuff this new type into the data product for our component.
        fault_response_last_id_received = self.get_with_name("Last_Fault_Id_Received")
        self.entities["Last_Fault_Id_Received"] = data_product(
            fault_response_last_id_received.name,
            model_name + ".T",
            description=fault_response_last_id_received.description,
            id=fault_response_last_id_received.id,
            suite=self,
        )

        # Let's also add the type to our suite and component's complex types:
        self.type_models.append(self.entities["Last_Fault_Id_Received"].type_model)
        self.component.complex_types[
            self.entities["Last_Fault_Id_Received"].type_model.name
        ] = self.entities["Last_Fault_Id_Received"].type_model
