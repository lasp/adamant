from models.data_products import data_products, data_product
from models.exceptions import ModelException
from util import model_loader
from util import redo


# This model is a specialized data product suite for the fault correction component.
# This class inherits from the normal data product model but adds some extra functionality
# needed for the fault correction component. In particular, one of the data products for
# the fault correction component derives its type from its autocoded input parameters.
# The code below stuffs this derived type into the correct data product at assembly
# load time.
class fault_correction_data_products(data_products):
    # This is just a "decorated" data product object, so make sure everyone treats it like that.
    def submodel_name(self):
        return "data_products"

    def set_assembly(self, assembly):
        # Make sure an assembly is set by the base class implementation.
        super(fault_correction_data_products, self).set_assembly(assembly)

        # Get the model for the fault responses so that we can create the status record.
        configs = self.component.init.get_parameter_value(
            "Fault_Response_Configurations"
        )
        fault_responses_package = configs.split(".")[0]
        # fault_responses_model = model_loader.try_load_model_by_name(
        #     fault_responses_package, model_types="fault_responses"
        # )

        # Build the type for the data product.
        model_name = fault_responses_package + "_Status_Record"
        model_path = model_loader.get_model_file_path(
            model_name, model_types=["record"]
        )
        if not model_path:
            raise ModelException(
                "Could not find fault response type model file: '" + model_name + "'."
            )

        # Make sure the model file has been autogenerated. Note that this causes a circular
        # dependency loop if set_submodels_and_components is not set to False in the generator
        # for the packet type.
        redo.redo_ifchange(model_path)

        # OK, now stuff this new type into the data product for our component.
        fault_response_statuses_dp = self.get_with_name("Fault_Response_Statuses")
        self.entities["Fault_Response_Statuses"] = data_product(
            fault_response_statuses_dp.name,
            model_name + ".T",
            description=fault_response_statuses_dp.description,
            id=fault_response_statuses_dp.id,
            suite=self,
        )

        # Let's also add the type to our suite and component's complex types:
        self.type_models.append(self.entities["Fault_Response_Statuses"].type_model)
        self.component.complex_types[
            self.entities["Fault_Response_Statuses"].type_model.name
        ] = self.entities["Fault_Response_Statuses"].type_model

        # Build the enum for the type.
        model_name = fault_responses_package + "_Enums"
        model_path = model_loader.get_model_file_path(model_name, model_types=["enums"])
        if not model_path:
            raise ModelException(
                "Could not find fault response type model file: '" + model_name + "'."
            )

        # Make sure the model file has been autogenerated. Note that this causes a circular
        # dependency loop if set_submodels_and_components is not set to False in the generator
        # for the packet type.
        redo.redo_ifchange(model_path)

        # Build the type for the data product.
        model_name = fault_responses_package + "_Packed_Id_Type"
        model_path = model_loader.get_model_file_path(
            model_name, model_types=["record"]
        )
        if not model_path:
            raise ModelException(
                "Could not find fault response type model file: '" + model_name + "'."
            )

        # Make sure the model file has been autogenerated. Note that this causes a circular
        # dependency loop if set_submodels_and_components is not set to False in the generator
        # for the packet type.
        redo.redo_ifchange(model_path)

        # OK, now stuff this new type into the data product for our component.
        fault_response_last_id_received = self.get_with_name("Last_Fault_Id_Received")
        self.entities["Last_Fault_Id_Received"] = data_product(
            fault_response_last_id_received.name,
            model_name + ".T",
            description=fault_response_last_id_received.description,
            id=fault_response_last_id_received.id,
            suite=self,
        )

        # Let's also add the type to our suite and component's complex types:
        self.type_models.append(self.entities["Last_Fault_Id_Received"].type_model)
        self.component.complex_types[
            self.entities["Last_Fault_Id_Received"].type_model.name
        ] = self.entities["Last_Fault_Id_Received"].type_model
