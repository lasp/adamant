from models.packets import packets, packet
from models.exceptions import ModelException
from util import model_loader
from util import redo


class parameters_packets(packets):
    """
    This model is a specialized packet suite for the Parameters packet. This
    class inherits from the normal packets model but adds some extra functionality
    needed to the parameters packet. In particular, the parameters packet's
    type is derived from data within the assembly that the packet is a part of. The
    type itself gets filled in in the "load_assembly" method.
    """
    def submodel_name(self):
        """This is just a "decorated" packet object, so make sure everyone treats it like that."""
        return "packets"

    def set_assembly(self, assembly):
        # Set assembly:
        self.assembly = assembly

        # Stuff the Parameters packet type with the autogenerated type based on the
        # assembly. Even though this packed record is not used by the FSW, this will
        # allow the Parameters packet format to be available for decoding by ground tools
        # using the standard method of packed records.
        for key, pkt in self.entities.items():
            # Handle a Parameters component.
            if (
                pkt.suite.component.name == "Parameters"
                and pkt.name == "Active_Parameters"
            ):
                # First, lets get the path to the model file that will be the type for this packet:
                param_table = self.component.init.get_parameter_value(
                    "parameter_Table_Entries"
                )
                param_table_package = param_table.split(".")[0]
                model_name = param_table_package + "_record"
                model_path = model_loader.get_model_file_path(
                    model_name, model_types=["record"]
                )
                if not model_path:
                    raise ModelException(
                        "Could not find Active_Parameters packet type model file: '"
                        + model_name
                        + "'."
                    )

                # Make sure the model file has been autogenerated. Note that this causes a circular
                # dependency loop if shallow_load is not set to True in the generator
                # for the packet type.
                redo.redo_ifchange(model_path)

                # Now replace the packet by a new packet with the autogenerated type.
                self.entities[key] = packet(
                    name=pkt.name,
                    type=model_name + ".T",
                    description=pkt.description,
                    id=pkt.id,
                    suite=pkt.suite,
                )

                # Let's also add the type to our suite and component's complex types:
                self.type_models.append(self.entities[key].type_model)
                self.component.complex_types[
                    self.entities[key].type_model.name
                ] = self.entities[key].type_model
            # Handle a component other than the Parameters component that shares the parameter table type.
            elif pkt.name.endswith("Parameters"):
                # First, lets get the path to the model file that will be the type for this packet.
                # The typical assembly pattern pairs each Parameter_Store with a Parameters component
                # via a shared Parameter_Manager, so we use that topology as a heuristic:
                #   Parameter_Manager --Working_..._Send--> Parameters (active table)
                #   Parameter_Manager --Primary_..._Send--> Parameter_Store (stored table)
                # By finding which Parameter_Manager routes to self.component (this Parameter_Store),
                # we can then find which Parameters component shares that same manager.
                # This assumes the above attachment convention. If the assembly deviates from this
                # pattern, the connection trace will fail and the fallback below will be used instead,
                # which finds the first Parameters component in the assembly. If neither approach
                # produces the correct result, this component should not use the parameters_packets
                # model type.
                model_path = None
                model_name = None

                # Step 1: Find the Parameter_Manager connected to this component instance.
                # Use "is" (object identity) rather than "==" because the base model class
                # defines __eq__ as filename comparison, which would match all instances of
                # the same component type. "is" correctly distinguishes individual instances.
                param_manager = None
                for conn in self.assembly.connections:
                    if (
                        conn.to_component is self.component
                        and conn.to_connector.name
                        == "Parameters_Memory_Region_T_Recv_Async"
                    ):
                        param_manager = conn.from_component
                        break

                # Step 2: Find the Parameters component wired to that Parameter_Manager.
                if param_manager is not None:
                    for conn in self.assembly.connections:
                        if (
                            conn.from_component is param_manager
                            and conn.to_component.name == "Parameters"
                        ):
                            param_table = conn.to_component.init.get_parameter_value(
                                "parameter_Table_Entries"
                            )
                            param_table_package = param_table.split(".")[0]
                            model_name = param_table_package + "_record"
                            model_path = model_loader.get_model_file_path(
                                model_name, model_types=["record"]
                            )
                            if not model_path:
                                raise ModelException(
                                    "Could not find Stored_Parameters packet type model file: '"
                                    + model_name
                                    + "'."
                                )
                            break

                # Fallback: search all components for a Parameters component. This preserves
                # the original behavior for assemblies with a single parameter store that are
                # not wired through a Parameter_Manager.
                if model_path is None:
                    for comp in self.assembly.components.values():
                        if comp.name == "Parameters":
                            param_table = comp.init.get_parameter_value(
                                "parameter_Table_Entries"
                            )
                            param_table_package = param_table.split(".")[0]
                            model_name = param_table_package + "_record"
                            model_path = model_loader.get_model_file_path(
                                model_name, model_types=["record"]
                            )
                            if not model_path:
                                raise ModelException(
                                    "Could not find Active_Parameters packet type model file: '"
                                    + model_name
                                    + "'."
                                )
                            break

                if not model_path:
                    raise ModelException(
                        "Could not find Parameters component in assembly."
                    )

                # Make sure the model file has been autogenerated. Note that this causes a circular
                # dependency loop if shallow_load is not set to True in the generator
                # for the packet type.
                redo.redo_ifchange(model_path)

                # Now replace the packet by a new packet with the autogenerated type.
                self.entities[key] = packet(
                    name=pkt.name,
                    type=model_name + ".T",
                    description=pkt.description,
                    id=pkt.id,
                    suite=pkt.suite,
                )

        # Call the base class version:
        super(parameters_packets, self).set_assembly(assembly)
