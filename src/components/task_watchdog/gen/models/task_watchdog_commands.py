from models.commands import commands, command
from models.exceptions import ModelException
from util import model_loader
from util import redo


# This model is a specialized command suite for the task watchdog component.
# This class inherits from the normal component model but adds a enumeration type to
# some of the command arguments which can be more easily understood by ops than a
# connector index.
class task_watchdog_commands(commands):
    # This is just a "decorated" data product object, so make sure everyone treats it like that.
    def submodel_name(self):
        return "commands"

    def set_assembly(self, assembly):
        # Make sure an assembly is set by the base class implementation.
        super(task_watchdog_commands, self).set_assembly(assembly)

        # Get the model for the downsampler to create data products for each item in the list
        watchdog_list = self.component.init.get_parameter_value(
            "Task_Watchdog_Entry_Init_List"
        )
        watchdog_list_package = watchdog_list.split(".")[0].replace(
            "_Task_Watchdog_List", ""
        )
        watchdog_list_model = model_loader.try_load_model_by_name(
            watchdog_list_package, model_types="task_watchdog_list"
        )
        if not watchdog_list_model:
            raise ModelException(
                "Could not find watchdog list model for the task watchdog data products: "
                + str(watchdog_list)
            )

        # Load command type model:
        model_name = watchdog_list.split(".")[0] + "_Watchdog_Limit_Cmd"
        model_path = model_loader.get_model_file_path(
            model_name, model_types=["record"]
        )
        if not model_path:
            raise ModelException(
                "Could not find task watchdog type model file: '" + model_name + "'."
            )

        # Make sure the model file has been autogenerated. Note that this causes a circular
        # dependency loop if set_submodels_and_components is not set to False in the generator
        # for the packet type.
        redo.redo_ifchange(model_path)

        # OK, now stuff this new type into the command for our component.
        cmd = self.get_with_name("Set_Watchdog_Limit")
        self.entities["Set_Watchdog_Limit"] = command(
            name=cmd.name,
            type=model_name + ".T",
            description=cmd.description,
            id=cmd.id,
            suite=self,
        )

        # Let's also add the type to our suite and component's complex types:
        self.type_models.append(self.entities["Set_Watchdog_Limit"].type_model)
        self.component.complex_types[
            self.entities["Set_Watchdog_Limit"].type_model.name
        ] = self.entities["Set_Watchdog_Limit"].type_model

        # Load command type model:
        model_name = watchdog_list.split(".")[0] + "_Watchdog_Action_Cmd"
        model_path = model_loader.get_model_file_path(
            model_name, model_types=["record"]
        )
        if not model_path:
            raise ModelException(
                "Could not find task watchdog type model file: '" + model_name + "'."
            )

        # Make sure the model file has been autogenerated. Note that this causes a circular
        # dependency loop if set_submodels_and_components is not set to False in the generator
        # for the packet type.
        redo.redo_ifchange(model_path)

        # OK, now stuff this new type into the command for our component.
        cmd = self.get_with_name("Set_Watchdog_Action")
        self.entities["Set_Watchdog_Action"] = command(
            name=cmd.name,
            type=model_name + ".T",
            description=cmd.description,
            id=cmd.id,
            suite=self,
        )

        # Let's also add the type to our suite and component's complex types:
        self.type_models.append(self.entities["Set_Watchdog_Action"].type_model)
        self.component.complex_types[
            self.entities["Set_Watchdog_Action"].type_model.name
        ] = self.entities["Set_Watchdog_Action"].type_model
