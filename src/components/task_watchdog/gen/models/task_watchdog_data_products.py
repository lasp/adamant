from models.data_products import data_products, data_product
from models.exceptions import ModelException
from util import model_loader
from util import redo


# This model is a specialized data product suite for the product extractor data products. This
# class inherits from the normal data products model but adds extra data products based on the user's model input.
class task_watchdog_data_products(data_products):
    # This is just a "decorated" data product object, so make sure everyone treats it like that.
    def submodel_name(self):
        return "data_products"

    def set_assembly(self, assembly):
        # Make sure an assembly is set by the base class implementation.
        super(task_watchdog_data_products, self).set_assembly(assembly)

        # Get the model for the downsampler to create data products for each item in the list
        data_product_list = self.component.init.get_parameter_value(
            "Task_Watchdog_Entry_Init_List"
        )
        data_product_list_package = data_product_list.split(".")[0].replace(
            "_Task_Watchdog_List", ""
        )
        data_product_list_model = model_loader.try_load_model_by_name(
            data_product_list_package, model_types="task_watchdog_list"
        )
        if not data_product_list_model:
            raise ModelException(
                "Could not find watchdog list model for the task watchdog data products: "
                + str(data_product_list)
            )

        model_name = data_product_list.split(".")[0] + "_State_Record"
        model_path = model_loader.get_model_file_path(
            model_name, model_types=["record"]
        )
        if not model_path:
            raise ModelException(
                "Could not find task watchdog type model file: '" + model_name + "'."
            )

        # Make sure the model file has been autogenerated. Note that this causes a circular
        # dependency loop if set_submodels_and_components is not set to False in the generator
        # for the packet type.
        redo.redo_ifchange(model_path)

        pet_connector_states_dp = self.get_with_name("Pet_Connector_Action_States")
        dp = data_product(
            name=pet_connector_states_dp.name,
            type=model_name + ".T",
            description=pet_connector_states_dp.description,
            id=None,
            suite=self,
        )
        self.entities[pet_connector_states_dp.name] = dp

        # Let's also add the type to our suite and component's complex types:
        self.type_models.append(dp.type_model)
        self.component.complex_types[dp.type_model.name] = dp.type_model

        # loop through the model to get all the data products we need to add
        for dp_component in data_product_list_model.watchdog_list.values():
            # Fill in our data product
            dp = data_product(
                name=dp_component.product_name + "_Limit",
                type="Packed_Missed_Pet_Limit.T",
                description=dp_component.description,
                id=None,
                suite=self,
            )
            self.entities[dp_component.product_name + "_Limit"] = dp

        # Let's also add the type to our suite and component's complex types:
        self.type_models.append(dp.type_model)
        self.component.complex_types[dp.type_model.name] = dp.type_model
