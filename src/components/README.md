# Component Library

This directory contains Adamant's reusable component library. Below is an index of what is included. Please update this
README.md when adding a new component to this directory.

 - [**ccsds_command_depacketizer**](ccsds_command_depacketizer/doc/ccsds_command_depacketizer.pdf) - This components extracts Adamant commands out of CCSDS command packets.
 - [**ccsds_downsampler**](ccsds_downsampler/doc/ccsds_downsampler.pdf) - This component downsamples (periodically drops) packets that are listed in the downsample list. The input list has two items, one is the APID, and the other is the filter factor.
 - [**ccsds_echo**](ccsds_echo/doc/ccsds_echo.pdf) - This component creates Adamant packets whose data is the CCSDS packets sent to it. The main use of this component is to echo a CCSDS stream from uplink back down as downlink.
 - [**ccsds_packetizer**](ccsds_packetizer/doc/ccsds_packetizer.pdf) - This components receives Adamant packets and converts them to CCSDS packets.
 - [**ccsds_product_extractor**](ccsds_product_extractor/doc/ccsds_product_extractor.pdf) - This component extracts data products from an incoming CCSDS packets and send them out.
 - [**ccsds_router**](ccsds_router/doc/ccsds_router.pdf) - This component routes CCSDS packets to output connectors based on a static table matching APID to the output connector index. Table lookup is done by binary searching against APID.
 - [**ccsds_serial_interface**](ccsds_serial_interface/doc/ccsds_serial_interface.pdf) - This component is meant to be a backdoor serial component which uses Ada.Text_IO to send a receive data over a serial port.
 - [**ccsds_socket_interface**](ccsds_socket_interface/doc/ccsds_socket_interface.pdf) - A socket interface component which sends/receives CCSDS packets.
 - [**ccsds_subpacket_extractor**](ccsds_subpacket_extractor/doc/ccsds_subpacket_extractor.pdf) - This component extracts CCSDS formatted subpackets from a larger CCSDS formatted packet.
 - [**command_protector**](command_protector/doc/command_protector.pdf) - This component implements "protected commands", ie. commands that can only executed if an "arm" is received first.
 - [**command_rejector**](command_rejector/doc/command_rejector.pdf) - This component drops commands received if they match a list of disallowed IDs.
 - [**command_router**](command_router/doc/command_router.pdf) - This component routes commands by ID to the correct component for execution.
 - [**command_sequencer**](command_sequencer/doc/command_sequencer.pdf) - This component executes command sequences with a configurable number of engines. The sequence engines execute sequences in the LASP Awesome Sequence Engine Language (LASEL) compiled by the LASP SEQ tool.
 - [**connector_counter_16**](connector_counter_16/doc/connector_counter_16.pdf) - This generic component attaches to a connector and counts the invocations occurring on that connector. It then reports this count as a data product and passes the connector invocation through to a connected component on the other side. The count rolls over at 2^16-1 and is 2 bytes wide.
 - [**connector_counter_8**](connector_counter_8/doc/connector_counter_8.pdf) - This generic component attaches to a connector and counts the invocations occurring on that connector. It then reports this count as a data product and passes the connector invocation through to a connected component on the other side. The count rolls over at 255 and is 1 byte wide.
 - [**connector_protector**](connector_protector/doc/connector_protector.pdf) - This is a generic component that can be used to protect (as in protected object) the call to the input connector. The component serves as a multi-tasking safe synchronization point for multiple callers.
 - [**connector_queuer**](connector_queuer/doc/connector_queuer.pdf) - This is a generic component that can be used to queue (as in recv_async) the call to an input connector. The component allows a queue to be added in front of a synchronous connector in any component. Adding a queue to a component not designed with thread-safety in mind can serve as a multi-tasking safe synchronization point for multiple callers.
 - [**cpu_monitor**](cpu_monitor/doc/cpu_monitor.pdf) - This component reports the CPU usage percentage for each active component and interrupt handler in the system.
 - [**event_filter**](event_filter/doc/event_filter.pdf) - This component is used to filter out events by ID. The component takes in a range of IDs valid for filtering and an initial list of event IDs to filter.
 - [**event_limiter**](event_limiter/doc/event_limiter.pdf) - This component is used to limit the number of events received too quickly. The purpose is to prevent event spamming from taking over the system.
 - [**event_packetizer**](event_packetizer/doc/event_packetizer.pdf) - This component builds a packet that includes variable sized events as subpackets. Events are sent to this component synchronously and stored into an internal packet. When the packet is full, or a timeout has occurred the packet is sent out of the component.
 - [**event_text_logger**](event_text_logger/doc/event_text_logger.pdf) - This component is designed for use on Linux. An received event is put into a queue until this active component is given time to execute. When executing, this component pulls events off its queue and prints them to the terminal for logging or immediate human inspection.
 - [**fault_correction**](fault_correction/doc/fault_correction.pdf) - This component receives faults asynchronously. Using an internal table it determines the correct command correction to send and sends it.
 - [**forwarder**](forwarder/doc/forwarder.pdf) - This is a generic component that can be used to forward a single connector of any type. The component that synchronously forwards any type that it receives. It includes commands to enable or disable this forwarding, so can be effectively used as a stream on/off switch.
 - [**gps_time**](gps_time/doc/gps_time.pdf) - This contains a get connector which returns time in GPS format with a U32 for seconds and a U32 for subseconds.  Subseconds is measured as fractions of a second, where 2^32 = 1 second.
 - [**interrupt_listener**](interrupt_listener/doc/interrupt_listener.pdf) - This component is used to allow connected components to ask (ie. poll) if an interrupt has occurred. This component updates the interrupt data every time an interrupt is received. It allows connected components to query the current interrupt data at any time through the `Get_Interrupt_Data` connector. This component is most useful on single tasked systems where a main loop polls this component to see if an interrupt has occurred in order to proceed. It may also be useful on other polling type systems where servicing an interrupt is not high priority, but rather something that needs to be checked occasionally.
 - [**interrupt_pender**](interrupt_pender/doc/interrupt_pender.pdf) - This component is used to block the execution of a connected component until an interrupt is received. The Interrupt Pender provides a `Wait_For_Interrupt_Data_Return` connector on which an external component will block until an interrupt occurs. When an interrupt is received, the interrupt data will be passed to the calling component, unblocking it, and allowing it to continue execution. A common use case for this component is to service a periodic system tick. If interrupts are received non-periodically, or not missing two close-together, subsequent interrupts is very important, you should use the Interrupt Servicer instead of this component. This component should only be used in multi-tasked systems, as it blocks the caller.
 - [**interrupt_servicer**](interrupt_servicer/doc/interrupt_servicer.pdf) - This component is used to pass execution to a connected component when an interrupt is received. The Interrupt Servicer contains an internal task which waits on an interrupt. When the interrupt is received the internal task is released and sends the interrupt data to an attached component, allowing it to execute. This component should only be used in multi-tasked systems. When in doubt of which interrupt handling component to choose for your application, choose the Interrupt Servicer.
 - [**last_chance_manager**](last_chance_manager/doc/last_chance_manager.pdf) - The purpose of this component is to manage a region of non-volatile memory where the last chance handler saves exception information, should one be thrown. This component provides commands to dump this region of memory and reset the contents of the memory to all zeros.
 - [**limiter**](limiter/doc/limiter.pdf) - Stores generic data received on an asynchronous receive connector on an internal queue and meters out the sending of the queued data based on a commandable rate.
 - [**logger**](logger/doc/logger.pdf) - This component is a generic logger, that takes a generic type and stores it in an internal circular buffer. The log can be enabled/disabled and dumped via command. The intention of this component is to be used for post-mortem type logging of events or other data.
 - [**memory_copier**](memory_copier/doc/memory_copier.pdf) - This component services a command to copy from one memory region to another.
 - [**memory_dumper**](memory_dumper/doc/memory_dumper.pdf) - This component has the ability to dump memory regions into packets and report CRCs of memory regions by command.
 - [**memory_manager**](memory_manager/doc/memory_manager.pdf) - The component manages access to a single memory location through a single pointer. When requested, the component loans out access to the pointer if it is available. The component will reject any requests to access the pointer again until the pointer is returned from the requester.
 - [**memory_packetizer**](memory_packetizer/doc/memory_packetizer.pdf) - This component receives pointers to regions of memory and sends out the data as packets.
 - [**memory_packetizer_fixed_id**](memory_packetizer_fixed_id/doc/memory_packetizer_fixed_id.pdf) - Like the memory_packetizer except the produced packets will always be created with a single, static APID.
 - [**memory_stuffer**](memory_stuffer/doc/memory_stuffer.pdf) - This component has the ability to stuff (write to) memory regions.
 - [**parameter_store**](parameter_store/doc/parameter_store.pdf) - This component is responsible for storing and managing a parameter table in a specific memory location (usually nonvolatile).
 - [**parameters**](parameters/doc/parameters.pdf) - This component is responsible for managing the active parameter set contained within parameterized components.
 - [**pid_controller**](pid_controller/doc/pid_controller.pdf) - This component is a generic component for PID control that uses proportional, integral, and derivative gains.
 - [**precision_time_protocol_master**](precision_time_protocol_master/doc/precision_time_protocol_master.pdf) - This component implements the master portion of the Precision Time Protocol (PTP). Any PTP slaves can use the messages from this component to measure their system time relative to the master, or use the master to synchronize their clocks.
 - [**product_database**](product_database/doc/product_database.pdf) - This component maintains a database of data product items. Only the latest single copy of each data product item is stored, and that value can be updated or fetched by ID via connectors.
 - [**product_packetizer**](product_packetizer/doc/product_packetizer.pdf) - This component builds a packets made of different data products that have been fetched (presumably from a database). Each packet is constructed and emitted periodically.
 - [**queue_monitor**](queue_monitor/doc/queue_monitor.pdf) - This component reports the queue usage percentage for each queued component in the system.
 - [**rate_group**](rate_group/doc/rate_group.pdf) - This component provides a task on which other components can execute. It is attached to an incoming software tick, and forwards this tick to any components connected to it, allowing them to execute. It also checks for cycle slips, should components take too long to execute.
 - [**register_stuffer**](register_stuffer/doc/register_stuffer.pdf) - This component services a commands to stuff and dump registers. This component is different than the memory stuffer/dumper in that it atomically sets 32-bit little endian registers, which is a requirement on some hardware.
 - [**sequence_store**](sequence_store/doc/sequence_store.pdf) - This component is responsible for storing and managing access to a set of memory regions (slots) which each hold a single sequence. The managed memory regions are usually located in nonvolatile storage and can be read or written to via this component.
 - [**splitter**](splitter/doc/splitter.pdf) - Splits a generic synchronous receive connector into an unconstrained array of send connectors. Any data received is copied to all connected send connectors.
 - [**stack_monitor**](stack_monitor/doc/stack_monitor.pdf) - This component reports the stack and secondary stack usage percentage for each active component in the system.
 - [**task_watchdog**](task_watchdog/doc/task_watchdog.pdf) - This component ensures that other critical tasks in the system are running, otherwise a fault is thrown.
 - [**tick_divider**](tick_divider/doc/tick_divider.pdf) - This component takes an incoming tick at a given frequency and sends out ticks at some configured multiple of the provided frequency. This component can be used to provide different frequency periodic ticks for execution of components throughout the system.
 - [**tick_listener**](tick_listener/doc/tick_listener.pdf) - This component is designed as a non-interrupt driven version of the Interrupt Listener component. It takes an incoming tick and counts how many it receives. A requester can ask the component if any ticks have been received, allowing it to make decisions based on whether or not a tick was received. This component is mostly useful in simulating interrupt patterns in software.
 - [**ticker**](ticker/doc/ticker.pdf) - This component provides a software driven periodic tick at a given frequency.
 - [**time_at_tone_master**](time_at_tone_master/doc/time_at_tone_master.pdf) - This is the Time at Tone Master component. TaT is a protocol used to sync a slave clock to a master clock.
 - [**time_of_tone_master**](time_of_tone_master/doc/time_of_tone_master.pdf) - Like time_at_tone_master, but could potentially be more accurate in some assemblies.
 - [**zero_divider**](zero_divider/doc/zero_divider.pdf) - This component provides a safe, commandable way to cause the Ada Last Chance Handler to be called. This component divides by zero when a specific command is received.
