import os.path
from util import redo
from util import error
from util import shell
from util import filesystem
from util import redo_arg
from util import tex
from util import jinja
from util import debug as debug_module
from shutil import rmtree
from shutil import copyfile, move
import glob
from base_classes.build_rule_base import build_rule_base
from database.redo_target_database import redo_target_database


# This build rule compiles a PDF file from any .tex file found
# in a non-"build" directory. It uses pdflatex under the hood
# to accomplish this.
class build_pdf(build_rule_base):
    def _build(self, redo_1, redo_2, redo_3):
        if not redo_arg.in_build_pdf_dir(redo_1):
            error.error_abort(
                "Pdf file '"
                + redo_1
                + "' can only be built in a 'build/pdf' directory."
            )

        # Depend on the tex file associated with this pdf. It has to
        # reside in a source directory, not a build directory.
        pdf_dir, base_name = redo_arg.split_redo_arg(redo_2)
        source_dir = redo_arg.get_src_dir(redo_2)
        tex_file_root = os.path.join(source_dir, base_name + ".tex")
        tex_file_build = os.path.join(
            os.path.join(source_dir, "build" + os.sep + "tex"), base_name + ".tex"
        )
        add_document = False
        tex_file = None

        # Is this a hand written tex file?:
        if os.path.isfile(tex_file_root):
            tex_file = tex_file_root
        # Is this an autogenerated tex file?:
        else:
            with redo_target_database() as db:
                try:
                    targets = db.get_targets_for_directory(source_dir)
                except BaseException:
                    targets = []
            if tex_file_build in targets:
                tex_file = tex_file_build
                add_document = True
            # No idea what the user is trying to build.
            else:
                error.error_abort(
                    "No source file found to build '"
                    + redo_1
                    + "'. Looking for '"
                    + tex_file_root
                    + "' or '"
                    + tex_file_build
                    + "'."
                )
        redo.redo_ifchange(tex_file)

        # Depend on all the includes in the tex file:
        tex.depend_on_tex_file(tex_file, source_dir)

        # Name definitions:
        tex_base, ext = os.path.splitext(tex_file)
        temp_tex_base = tex_base + "_tmp"
        temp_tex_file = temp_tex_base + ".tex"
        cwd = os.getcwd()

        def clean_up():
            # Move over latex temporary files:
            for f in glob.iglob(temp_tex_base + "*"):
                base = os.path.basename(f)
                move(f, os.path.join(pdf_dir, base))
            # Move over minted temporary directory:
            for f in glob.iglob(
                os.path.dirname(temp_tex_base) + os.sep + "_minted-*_tmp"
            ):
                base = os.path.basename(f)
                out = os.path.join(pdf_dir, base)
                try:
                    rmtree(out)
                except FileNotFoundError:
                    pass
                move(f, out)
            os.chdir(cwd)

        # Build the pdf file, we make a temporary version of the tex file, to
        # do this safely. We also need to be in the same directory as the
        # .tex file to make a pdf.
        try:
            filesystem.safe_makedir(pdf_dir)
            os.chdir(os.path.dirname(tex_file))
            if add_document:
                output = jinja.render(
                    {
                        "prettyname": base_name.replace("_", " "),
                        "full_file_name": tex_file,
                    },
                    "/tex/stub.tex",
                )
                with open(temp_tex_file, "w") as f:
                    f.write(output)
            else:
                copyfile(tex_file, temp_tex_file)
            assert (
                "ADAMANT_DIR" in os.environ
            ), "This build file needs to be run within the Adamant environment."
            tex_inputs_dir = os.path.join(
                os.environ["ADAMANT_DIR"],
                "gen" + os.sep + "templates" + os.sep + "tex" + os.sep + "inputs",
            )

            def make_pdf(the_tex_inputs_dir, the_temp_tex_file):
                stdout = None
                stderr = None
                if debug_module.is_debug_on():
                    status = shell.try_run_command(
                        "TEXINPUTS=$TEXINPUTS:"
                        + the_tex_inputs_dir
                        + " texfot pdflatex --shell-escape "
                        + the_temp_tex_file
                        + " >&2"
                    )
                else:
                    status, stdout, stderr = shell.try_run_command_capture_output(
                        "TEXINPUTS=$TEXINPUTS:"
                        + the_tex_inputs_dir
                        + " texfot pdflatex --shell-escape "
                        + the_temp_tex_file
                    )
                if status != 0:
                    import sys

                    if stdout:
                        sys.stderr.write(stdout + "\n")
                    if stderr:
                        sys.stderr.write(stderr + "\n")
                    clean_up()
                    error.abort(status)

            # Run first time.
            redo.info_print("Building pdf...")
            make_pdf(tex_inputs_dir, temp_tex_file)

            # Run second time if a .toc file was found. This allows table of contents
            # to get rendered correctly if there is one.
            if os.path.exists(temp_tex_base + ".toc"):
                redo.info_print("Building pdf table of contents...")
                make_pdf(tex_inputs_dir, temp_tex_file)

            # Move file to redo 3:
            if os.path.isfile(temp_tex_base + ".pdf"):
                move(temp_tex_base + ".pdf", redo_3)

        except Exception as e:
            clean_up()
            raise e

        clean_up()

    # Match any .tex file.
    def input_file_regex(self):
        return r".*\.tex$"

    # If the .tex file provided is in a "build" directory
    # we ignore it and do not return an output name. If the
    # .tex file is not in a "build" directory we return a
    # pdf file with the same name in the build/pdf directory.
    def output_filename(self, input_filename):
        # This rule only exists for tex files that are
        # in a regular directory or in the build/tex directory
        directory = None
        if redo_arg.in_build_tex_dir(input_filename):
            directory = redo_arg.get_src_dir(input_filename)
        elif not redo_arg.in_build_dir(input_filename):
            directory = os.path.dirname(input_filename)
        else:
            return None

        base = redo_arg.get_base_no_ext(input_filename)
        return os.path.join(
            directory, "build" + os.sep + "pdf" + os.sep + base + ".pdf"
        )
